using Microsoft.AspNetCore.Mvc;

namespace Techcore_Internship.WebApi.Controllers;

[ApiController]
[Route("api/[controller]")]
public class Task349_1_HttpClientVsHttpClientFactoryController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        var result = new
        {
            essay = @"Проблема исчерпания сокетов и решение через HttpClientFactory

В мире .NET-разработки существует коварная проблема, известная как 'Socket Exhaustion' (исчерпание сокетов), которая возникает при неправильном использовании HttpClient. 
Многие разработчики, особенно новички, instinctively используют паттерн using с HttpClient, не осознавая катастрофических последствий этого подхода.

Проблема заключается в фундаментальном непонимании природы сетевых ресурсов. Когда мы создаем HttpClient через 'using (var client = new HttpClient())', мы предполагаем, что ресурсы освобождаются немедленно. 
Однако реальность такова, что сокетные соединения переходят в состояние TIME_WAIT и остаются занятыми в течение 2-4 минут после Dispose(). Это ограничение протокола TCP, а не .NET.

Представьте себе парковку с ограниченным количеством мест. Каждый using-блок - это машина, которая занимает место на несколько часов после того, как водитель ушел. 
После 1000 таких 'посетителей' парковка переполняется, и новые клиенты не могут приехать. 
Именно это происходит с сокетами - операционная система имеет жесткий лимит на одновременные соединения (обычно ~16,000 в Windows).

HttpClientFactory решает эту проблему через элегантную систему управления пулом соединений. Вместо создания и уничтожения сокетов, фабрика поддерживает 'парк' переиспользуемых соединений. 
Когда приложению нужен HttpClient, фабрика не создает новый сокет, а выдает существующее соединение из пула. После использования соединение не уничтожается, а возвращается в пул для следующего запроса.

Это похоже на систему каршеринга: вместо того чтобы покупать новую машину для каждой поездки (using), вы берете автомобиль из парка (CreateClient), используете его и возвращаете обратно. 
Ресурсы используются оптимально, 'парковочные места' не переполняются.

Помимо решения проблемы сокетов, HttpClientFactory предоставляет ряд других критически важных преимуществ:

- Интеллектуальное управление DNS: предотвращает проблемы с устаревшим DNS-кэшем, которые возникают при долгоживущих HttpClient экземплярах. 
Фабрика автоматически обновляет DNS-записи, обеспечивая подключение к актуальным IP-адресам серверов.

- Встроенные механизмы Retry-логики: через библиотеку Polly фабрика позволяет легко настраивать политики повторных попыток, обработки сбоев и circuit breaker. 
Это значительно повышает отказоустойчивость приложения при временных сетевых проблемах.

- Централизованная конфигурация: все настройки HttpClient (timeout, base address, headers) определяются в одном месте, что обеспечивает согласованность поведения и упрощает поддержку кода.

- Улучшенная наблюдаемость: фабрика предоставляет детальное логирование всех HTTP-запросов, что облегчает диагностику проблем в production-среде.

- Управление временем жизни: фабрика автоматически управляет временем жизни соединений, предотвращая как преждевременное закрытие, так и излишнее накопление устаревших соединений."
        };
        return Ok(result);
    }
}
