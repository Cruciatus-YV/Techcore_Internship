namespace Techcore_Internship.Module_2;

public static class Task337_8_SynchronizationContext
{
    public static void Run()
    {
        Console.WriteLine("\nTask337.8 - SynchronizationContext\n");
        Console.WriteLine(@"SynchronizationContext — это абстракция, которая описывает в какой среде должен продолжиться код после await.
Он определяет ""контекст выполнения"", то есть, в каком потоке и каким образом возобновлять выполнение метода после асинхронной операции.)

    По умолчанию .(ConfigureAwait(true): await захватывает текущий SynchronizationContext, а потом возвращает выполнение в тот же контекст.
.ConfigureAwait(false) отключает захват текущего контекста и позволяет продолжить выполнение в любом доступном потоке из пула потоков.
В библиотечном коде всегда пишут .ConfigureAwait(false) потому что не известно заранее, в каком контексте она будет использоваться. Это может быть: 
- UI-приложение (WPF),
- веб-сервер (ASP.NET),
- консольная утилита,
- служба Windows.

Если библиотечный метод захватит контекст вызвавшего кода,
это может привести к deadlock’ам (взаимным блокировкам) или к лишнему переключению потоков.

Пример кода, приводящего к взаимной блокировке:
---------------------------------------------------------------------
// UI-код
var result = SomeLibrary.DoWorkAsync().Result; // блокируем UI-поток

// Код в библиотеке
public static async Task DoWorkAsync()
{
    await Task.Delay(1000); // вернётся в UI-контекст!
}
---------------------------------------------------------------------
В итоге получается:
- UI-поток ждёт .Result (заблокирован),
- await хочет вернуться в UI-поток, но он заблокирован => Deadlock

Правильный вариант:
---------------------------------------------------------------------
public static async Task DoWorkAsync()
{
    await Task.Delay(1000).ConfigureAwait(false); // не вернётся в UI-контекст!
}
---------------------------------------------------------------------
Теперь после await выполнение продолжится в любом свободном потоке пула. 
Код не попытается вернуться в UI-поток => никаких взаимных блокировок.
");
    }
}